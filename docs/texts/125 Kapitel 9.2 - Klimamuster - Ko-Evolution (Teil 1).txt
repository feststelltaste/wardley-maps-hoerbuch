Kapitel 9.2.: Klimamuster : Ko-Evolution

   Im Jahr 2016 dreht sich alles um "serverloses" Computing. Ich werde diesen glücklichen Umstand ausnutzen, um das Konzept der Co-Evolution zu erklären, aber zunächst müssen wir eine Zeitreise in die 80er/90er Jahre machen. Damals waren Computer vor allem ein Produkt, und die Anwendungen, die wir entwickelten, verwendeten Architekturpraktiken, die auf den Eigenschaften eines Produkts basierten, insbesondere auf der Mittelzeit bis zur Wiederherstellung (MTTR)

   Wenn ein Computer ausfiel, mussten wir ihn ersetzen oder reparieren, und das würde Zeit kosten. Die MTTR war hoch und es hatten sich architektonische Praktiken herausgebildet, um damit umzugehen. Wir bauten Maschinen mit N 1 (d. h. redundante Komponenten wie mehrere Netzteile). Wir führten Disaster-Recovery-Tests durch, um sicherzustellen, dass unsere Ausfallsicherheit funktionierte. Wir kümmerten uns sehr um die Kapazitätsplanung und die Skalierung einzelner Maschinen (Scale-up). Wir kümmerten uns sehr um Dinge, die Fehler einführen könnten, und wir hatten Verfahren zur Änderungskontrolle, um dies zu verhindern. Normalerweise bauten wir Testumgebungen, um Dinge auszuprobieren, bevor wir in Versuchung kamen, die wichtige Produktionsumgebung zu verändern

   Aber diese Praktiken sind nicht einfach über Nacht auf magische Weise entstanden, sondern haben sich durch Versuch und Irrtum entwickelt. Sie begannen als neuartige Praktiken, dann tauchten dominantere, aber abweichende Formen auf, bis wir schließlich eine Art von Konsens erreichten. Die Techniken konvergierten und eine gute Praxis war geboren. Das Gleiche geschah mit der Buchhaltung, mit der Fertigung, mit der Personalabteilung und jeder anderen Geschäftspraxis, die Sie sich vorstellen können. Letztendlich wurden diese architektonischen Praktiken verfeinert und die beste architektonische Praxis entwickelt. In diesen zuversichtlichen Tagen wurde man dafür verspottet, dass man keine ordentliche Kapazitätsplanung durchgeführt hatte, da dies eine erwartete Norm war

   Unsere Anwendungen benötigten architektonische Praktiken, die auf (benötigter) Rechenleistung basierten, die als Produkt bereitgestellt wurde. Die architektonischen Normen, die zu "Best Practice" wurden, waren N 1, Scale-up, Disaster Recovery, Änderungskontrolle und Testumgebungen und diese wurden letztendlich von der hohen MTTR eines Produkts abgeleitet. Ich habe diese Entwicklung der Praxis in der Karte unten dargestellt
Siehe    Abbildung 97: Entwicklung der architektonischen Praxis für mehr Details.

   Normalerweise verwende ich bei Maps nur die Beschreibung der Evolution für Aktivitäten. Diese Evolution ist bei der Praxis genau dasselbe, nur mit etwas anderen Begriffen, z.B. neuartig, aufstrebend, gut und am besten statt Genese, Brauch, Produkt und Ware. Für Hintergrundinformationen dazu siehe [128]figure 10 ([129]Chapter 2)

   Die Sache ist die: Compute hat sich entwickelt. Als Aktivität hatte Compute damals in den 1940er Jahren in jenem unerforschten Raum begonnen (die Genese der Handlung), in dem alles ungewiss ist. Dann gab es speziell angefertigte Beispiele (divergente Formen) und dann Produkte (Konvergenz um bestimmte Merkmale mit einer gewissen Differenzierung zwischen ihnen). In den frühen 2000er Jahren begann sich die Datenverarbeitung jedoch zu wandeln und wurde immer mehr zur Massenware, wobei die Differenzierung viel stärker eingeschränkt wurde und die Tätigkeit selbst viel stärker definiert wurde. In dieser Welt ging es bei einem Server wirklich um Prozessorgeschwindigkeit, Arbeitsspeicher, Festplattengröße, Stromverbrauch und wie viele man in ein Rack packen konnte. In dieser Welt bauten wir Rechenbanken und erstellten virtuelle Maschinen, wenn wir sie brauchten. Dann bekamen wir mit der Ankunft von AWS EC2 im Jahr 2006 öffentliche Versorgungsformen

   Die stärker industrialisierten Formen jeder Aktivität haben andere Eigenschaften als die frühen, sich entwickelnden Versionen. Bei der Computerinfrastruktur hatten die damaligen Utility-Formen ähnliche Verarbeitungs-, Speicher- und Ablagemöglichkeiten, aber sie hatten eine sehr niedrige MTTR. Wenn ein virtueller Server kaputt ging, machten wir uns nicht die Mühe, ihn zu reparieren, wir bestellten keinen neuen, wir riefen einfach eine API auf und innerhalb von Minuten oder Sekunden hatten wir einen neuen. Die Zeiten, in denen wir unseren Servern liebevolle Namen gaben, waren lange vorbei, das waren keine Haustiere, sondern Vieh

