Kapitel 9.2.1.: Erschwert das Bild noch ein wenig - der Aufstieg von Serverless

   Natürlich zeigt Ihnen die Karte selbst nicht das ganze Bild, denn ich habe sie bewusst vereinfacht, um die Co-Evolution zu erklären. Zwischen der Anwendung und der architektonischen Praxis, die wir für die Computing-Infrastruktur verwendet haben, liegt eine weitere Schicht - die Plattform. Nun entwickelt sich die Plattform selbst weiter. Irgendwann in der Vergangenheit gab es die Entstehung der ersten Plattformen. Diese entwickelten sich dann zu verschiedenen abweichenden, aber immer noch unüblichen kundenspezifischen Formen. Dann hatten wir eine Konvergenz zu mehr Produktformen. Wir hatten Dinge wie den LAMP-Stack (Linux, Apache, MySql und Perl oder Python oder PHP - wählen Sie Ihr Gift)

   Neben der architektonischen Praxis rund um die Computing-Infrastruktur gab es auch architektonische Praktiken rund um die Plattform. Diese basierten auf den Eigenschaften der Plattform selbst. Von Codierungsstandards (d. h. Nomenklatur) über Test-Suites und Leistungstests bis hin zu objektorientiertem Design innerhalb monolithischer Programmstrukturen. Das Hauptmerkmal der Plattform war, dass sie eine gemeinsame Umgebung für den Code bereitstellte und viele der zugrundeliegenden Funktionen abstrahierte. Aber dies geschah zu einem Preis, eben dieser gemeinsamen Plattform

   Wie ich bereits erwähnt habe, ist ein Programm nichts anderes als eine High-Level-Funktion, die oft viele andere Funktionen aufruft. Im Allgemeinen haben wir diese Funktionen jedoch insgesamt als eine Art monolithische Struktur kodiert. Wir haben vielleicht ein paar Schichten in einer Art n-Schichten-Design abgetrennt - eine Web-Schicht, ein Backend, ein Speichersystem - aber jede dieser Schichten neigte dazu, relativ große Programme zu haben. Um die Last zu bewältigen, replizierten wir die Monolithen oft über mehrere physische Maschinen. Innerhalb dieser großen Programme brachen wir sie in kleinere Funktionen auf, um sie besser verwalten zu können, aber seltener trennten wir diese Funktionen auf einen anderen Plattformstapel, weil der Overhead all dieser verschiedenen Plattformstapel zu groß war. Man wollte nicht eine Maschine mit einem ganzen Plattformstapel haben, um eine Funktion auszuführen, die nur selten aufgerufen wurde. Es war eine Verschwendung! In der Karte unten habe ich die
   Plattform und die Best Practice oberhalb der Plattformebene hinzugefügt
Siehe    Abbildung 100: Entwicklung der architektonischen Praxis (Plattform) für mehr Details.

   Im Jahr 2005 nutzte das Unternehmen, das ich leitete, bereits eine utility-ähnliche Infrastruktur. Wir hatten frühe DevOps-Praktiken entwickelt - verteilte Systeme, kontinuierliches Deployment, Design for Failure - und das war für uns einfach die Norm. Allerdings hatten wir auch die Utility-Coding-Plattform namens Zimki entwickelt, die es Entwicklern ermöglichte, ganze Anwendungen, Front- und Backend, in einer einzigen Sprache zu schreiben - JavaScript. Als Entwickler schrieb man einfach nur Code, man war von der Plattform selbst abstrahiert, man hatte sicherlich kein Konzept von Servern. Dass jede Funktion, die Sie innerhalb Ihres Programms schrieben, in einem anderen Plattform-Stack laufen könnte, war etwas, das Sie nicht wissen mussten. Vom Standpunkt des Entwicklers aus schrieb man einfach sein Programm und führte es aus, und es rief andere Funktionen auf. Diese Umgebung ermöglichte jedoch einige bemerkenswerte neue Möglichkeiten, von der Verteilung von Funktionen bis zur Abrechnung
   nach Funktionen. Der Wechsel der Plattform vom Produkt zum Dienstprogramm schuf neue Eigenschaften, die es ermöglichten, neue Architekturpraktiken auf dieser Ebene zu entwickeln. Das ist Ko-Evolution. Das ist normal. Diese neuen Praktiken habe ich mit dem Spitznamen FinDev versehen. Die "alten" bewährten architektonischen Praktiken, nun, das ist das Erbe. Ich habe eine Karte gezeichnet, um diese Veränderung zu zeigen
Siehe    Abbildung 101: Co-Evolution der architektonischen Praxis (Plattform) für mehr Details.

   Die banalere dieser architektonischen Änderungen besteht darin, dass sie die Komponentisierung fördert, also die Zerlegung komplexer Systeme in wiederverwendbare diskrete Komponenten, die anderen als Dienste zur Verfügung gestellt werden. In Zimki konnte jede Funktion durch einen einfachen "Publish"-Parameter, der der Funktion hinzugefügt wurde, als Webdienst bereitgestellt werden. Heute verwenden wir den Begriff Microservices, um diese Trennung von Funktionen und die Bereitstellung als Webservice zu beschreiben. Wir bewegen uns weg von dem monolithischen Programm, das alle Funktionen enthält, hin zu einer Welt getrennter und diskreter Funktionen. Eine Utility-Plattform ermöglicht dies erst und abstrahiert den gesamten zugrunde liegenden Prozess vom Entwickler

   Der nächste banale Punkt ist, dass es ein weitaus höheres Maß an Wiederverwendung fördert. Eines der Probleme in der alten objektorientierten Welt war, dass es keinen effektiven Kommunikationsmechanismus gab, um zu zeigen, was gebaut worden war. Oft wurden Objekte und Funktionen innerhalb eines Unternehmens dupliziert, ganz zu schweigen von denen zwischen Unternehmen. Auch hier ermutigt die Offenlegung als Webdienste dazu, dies zu ändern. Das setzt voraus, dass jemand den Sinn hat, einen Erkennungsmechanismus wie z. B. ein Dienstregister zu erstellen

   Ein weiterer, wiederum eher trivialer Punkt ist, dass es den Entwickler weiter von den Problemen der zugrunde liegenden Infrastruktur abstrahiert. Es ist nicht wirklich "serverlos", sondern eher "es ist mir egal, was ein Server ist". Wie bei jedem Prozess der Industrialisierung (ein Wechsel von Produkt- zu Commodity- und Utility-Formen) liegen die Vorteile nicht nur in der Effizienz der zugrunde liegenden Komponenten, sondern auch in der Beschleunigung der Geschwindigkeit, mit der ich neue Dinge entwickeln kann. Wie bei jeder anderen Industrialisierung wird es endlose Runden der Trägheit geben, die durch vergangene Praktiken verursacht wird. Erwarten Sie viel Zähneknirschen über die Vorteile der Anpassung Ihrer Infrastruktur an Ihre Plattform und …​ drehen Sie einfach die Uhr zurück zu Infrastructure as a Service im Jahr 2007 und Sie werden die gleichen Argumente in einem etwas anderen Kontext hören

   Wie auch immer, zurück zur Old Street (wo die Firma war) und den Tagen von 2005. Mit Zimki baute ich eine kleine Handelsplattform in einem Tag oder so, weil ich so viele Funktionen wiederverwenden konnte, die von anderen erstellt wurden. Ich musste mir keine Gedanken über den Aufbau einer Plattform machen und das Konzept eines Servers, Kapazitätsplanung und all das "Gequatsche" war weit weg von meinen Gedanken. Die Effizienz, die Schnelligkeit der Agilität und die Geschwindigkeit der Entwicklung sind einfach eine Selbstverständlichkeit. Allerdings sind diese Änderungen nicht wirklich die spannenden Teile. Der Killer, das "gotcha" ist die Abrechnung nach Funktion. Dies ändert die Art und Weise, wie Sie die Überwachung durchführen, grundlegend und ermöglicht Konzepte wie die wertbasierte Entwicklung (siehe [134]chapter 8). Die Überwachung nach Funktionskosten verändert die Art und Weise, wie wir arbeiten - nun, es hat mich verändert und ich bin mir ziemlich sicher, dass dies Auswirkungen auf
   alle von Ihnen hat

   "Serverless" wird die Art und Weise, wie wir das Geschäft rund um die Technologie aufbauen und wie Sie programmieren, grundlegend verändern. Es wird eine ganz neue Reihe von Praktiken schaffen und Ihre Zukunft im Jahr 2016 sieht eher wie Abbildung 102 aus (nehmen Sie einfach die Co-Evolution of Architectural Practice-Karte von oben und entfernen Sie die Legacy-Linien). Natürlich ist das noch nicht passiert, aber durch die einfache Wiederanwendung eines allgemeinen Musters der Ko-Evolution kann ich eine ziemlich vernünftige Aussage für die Zukunft machen. Ich kann die Ko-Evolution nutzen, um eine Veränderung zu antizipieren
Siehe    Abbildung 102: Die Zukunft der Plattform für mehr Details.

   Angesichts unseres Wissens über dieses klimatische Muster fügen wir also die Ko-Evolution auf unserer Karte der Antizipation hinzu - siehe Abbildung 103 - und fügen Punkt 7 für die Ko-Evolution hinzu. Ich habe die Karte für jede beliebige Aktivität README.md verallgemeinert, ausgehend von einer frühen Version A[1] zu einer späteren, weiter entwickelten Handlung A[1 n] nach n Iterationen, jede mit ihrer eigenen Diffusionskurve. Dies führt sowohl zu mitentwickelter Praxis CONTRIBUTING.md als auch zu neuen Formen von Aktivitäten CODE_OF_CONDUCT.md CONTRIBUTING.md LICENCE.md
Siehe    Abbildung 103: Erweiterung der Antizipation mit Co-Evolution für mehr Details.

   Das obige ist bemerkenswert mächtig und erlaubt uns, unseren ersten Wirtschaftszyklus einzuführen, ein klimatisches Muster, das als Frieden, Krieg und Wunder bekannt ist

