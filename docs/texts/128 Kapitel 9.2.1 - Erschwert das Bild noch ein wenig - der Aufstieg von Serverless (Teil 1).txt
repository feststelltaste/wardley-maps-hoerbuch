Kapitel 9.2.1.: Erschwert das Bild noch ein wenig - der Aufstieg von Serverless

   Natürlich zeigt Ihnen die Karte selbst nicht das ganze Bild, denn ich habe sie bewusst vereinfacht, um die Co-Evolution zu erklären. Zwischen der Anwendung und der architektonischen Praxis, die wir für die Computing-Infrastruktur verwendet haben, liegt eine weitere Schicht - die Plattform. Nun entwickelt sich die Plattform selbst weiter. Irgendwann in der Vergangenheit gab es die Entstehung der ersten Plattformen. Diese entwickelten sich dann zu verschiedenen abweichenden, aber immer noch unüblichen kundenspezifischen Formen. Dann hatten wir eine Konvergenz zu mehr Produktformen. Wir hatten Dinge wie den LAMP-Stack (Linux, Apache, MySql und Perl oder Python oder PHP - wählen Sie Ihr Gift)

   Neben der architektonischen Praxis rund um die Computing-Infrastruktur gab es auch architektonische Praktiken rund um die Plattform. Diese basierten auf den Eigenschaften der Plattform selbst. Von Codierungsstandards (d. h. Nomenklatur) über Test-Suites und Leistungstests bis hin zu objektorientiertem Design innerhalb monolithischer Programmstrukturen. Das Hauptmerkmal der Plattform war, dass sie eine gemeinsame Umgebung für den Code bereitstellte und viele der zugrundeliegenden Funktionen abstrahierte. Aber dies geschah zu einem Preis, eben dieser gemeinsamen Plattform

   Wie ich bereits erwähnt habe, ist ein Programm nichts anderes als eine High-Level-Funktion, die oft viele andere Funktionen aufruft. Im Allgemeinen haben wir diese Funktionen jedoch insgesamt als eine Art monolithische Struktur kodiert. Wir haben vielleicht ein paar Schichten in einer Art n-Schichten-Design abgetrennt - eine Web-Schicht, ein Backend, ein Speichersystem - aber jede dieser Schichten neigte dazu, relativ große Programme zu haben. Um die Last zu bewältigen, replizierten wir die Monolithen oft über mehrere physische Maschinen. Innerhalb dieser großen Programme brachen wir sie in kleinere Funktionen auf, um sie besser verwalten zu können, aber seltener trennten wir diese Funktionen auf einen anderen Plattformstapel, weil der Overhead all dieser verschiedenen Plattformstapel zu groß war. Man wollte nicht eine Maschine mit einem ganzen Plattformstapel haben, um eine Funktion auszuführen, die nur selten aufgerufen wurde. Es war eine Verschwendung! In der Karte unten habe ich die
   Plattform und die Best Practice oberhalb der Plattformebene hinzugefügt
Siehe    Abbildung 100: Entwicklung der architektonischen Praxis (Plattform) für mehr Details.

   Im Jahr 2005 nutzte das Unternehmen, das ich leitete, bereits eine utility-ähnliche Infrastruktur. Wir hatten frühe DevOps-Praktiken entwickelt - verteilte Systeme, kontinuierliches Deployment, Design for Failure - und das war für uns einfach die Norm. Allerdings hatten wir auch die Utility-Coding-Plattform namens Zimki entwickelt, die es Entwicklern ermöglichte, ganze Anwendungen, Front- und Backend, in einer einzigen Sprache zu schreiben - JavaScript. Als Entwickler schrieb man einfach nur Code, man war von der Plattform selbst abstrahiert, man hatte sicherlich kein Konzept von Servern. Dass jede Funktion, die Sie innerhalb Ihres Programms schrieben, in einem anderen Plattform-Stack laufen könnte, war etwas, das Sie nicht wissen mussten. Vom Standpunkt des Entwicklers aus schrieb man einfach sein Programm und führte es aus, und es rief andere Funktionen auf. Diese Umgebung ermöglichte jedoch einige bemerkenswerte neue Möglichkeiten, von der Verteilung von Funktionen bis zur Abrechnung
   nach Funktionen. Der Wechsel der Plattform vom Produkt zum Dienstprogramm schuf neue Eigenschaften, die es ermöglichten, neue Architekturpraktiken auf dieser Ebene zu entwickeln. Das ist Ko-Evolution. Das ist normal. Diese neuen Praktiken habe ich mit dem Spitznamen FinDev versehen. Die "alten" bewährten architektonischen Praktiken, nun, das ist das Erbe. Ich habe eine Karte gezeichnet, um diese Veränderung zu zeigen
Siehe    Abbildung 101: Co-Evolution der architektonischen Praxis (Plattform) für mehr Details.

   Die banalere dieser architektonischen Änderungen besteht darin, dass sie die Komponentisierung fördert, also die Zerlegung komplexer Systeme in wiederverwendbare diskrete Komponenten, die anderen als Dienste zur Verfügung gestellt werden. In Zimki konnte jede Funktion durch einen einfachen "Publish"-Parameter, der der Funktion hinzugefügt wurde, als Webdienst bereitgestellt werden. Heute verwenden wir den Begriff Microservices, um diese Trennung von Funktionen und die Bereitstellung als Webservice zu beschreiben. Wir bewegen uns weg von dem monolithischen Programm, das alle Funktionen enthält, hin zu einer Welt getrennter und diskreter Funktionen. Eine Utility-Plattform ermöglicht dies erst und abstrahiert den gesamten zugrunde liegenden Prozess vom Entwickler

